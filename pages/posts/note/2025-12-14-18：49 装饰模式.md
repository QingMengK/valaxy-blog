---
title:
 -装饰模式
created: 2025-12-06
updated: 2025-12-06
type: 📘 知识节点
tags:
  - 面向对象
  - 设计模式
---
> 摘要：装饰模式通过组合和包装的方式，在不改变原有对象的情况下，为对象动态地增加新功能，是继承的一种灵活替代方案。

## 一、模式背景（小故事 🌱）

你在开发一个**咖啡点单系统**：

- 最基础的咖啡：`Coffee`
    
- 但用户可以**加牛奶**
    
- 也可以**加糖**
    
- 还可以 **牛奶 + 糖 + 巧克力 + 奶泡……**
    

问题来了：

❌ 如果你用继承，会出现什么？

```text
Coffee
├── CoffeeWithMilk
├── CoffeeWithSugar
├── CoffeeWithMilkAndSugar
├── CoffeeWithMilkSugarChocolate
├── ...
```
👉 **类爆炸**  
👉 新组合一多，维护崩溃

于是你遇到了一个需求：

> **“我希望在不修改原有类的情况下，动态地给对象添加功能。”**

这正是 —— **装饰模式** 的用武之地。

---

## 二、装饰模式是什么？

**定义（简化版）**：

> 装饰模式：  
> **在不改变原有对象结构的前提下，动态地为对象添加新的功能。**

📌 核心思想一句话：

> **用“组合”代替“继承”，一层一层地包裹对象。**

---

## 三、模式结构（角色说明）

装饰模式通常包含 4 个角色：

1. **Component（抽象组件）**
    
    - 定义基本行为接口
        
2. **ConcreteComponent（具体组件）**
    
    - 最原始、最基础的对象
        
3. **Decorator（抽象装饰器）**
    
    - 持有一个 Component
        
4. **ConcreteDecorator（具体装饰器）**
    
    - 给组件“加功能”
        

---

## 四、C++ 示例（推荐你记这个）

### 1️⃣ 抽象组件（Component）
```cpp
#include <iostream>
#include <string>

class Coffee {
public:
    virtual std::string getDescription() = 0;
    virtual double cost() = 0;
    virtual ~Coffee() {}
};
```
---

### 2️⃣ 具体组件（ConcreteComponent）

```cpp
class SimpleCoffee : public Coffee {
public:
    std::string getDescription() override {
        return "Simple Coffee";
    }

    double cost() override {
        return 10.0;
    }
};
```

---

### 3️⃣ 抽象装饰器（Decorator）

```cpp
class CoffeeDecorator : public Coffee {
protected:
    Coffee* coffee;

public:
    CoffeeDecorator(Coffee* c) : coffee(c) {}
};
```
---

### 4️⃣ 具体装饰器（ConcreteDecorator）

#### ☕ 加牛奶

```cpp
class MilkDecorator : public CoffeeDecorator {
public:
    MilkDecorator(Coffee* c) : CoffeeDecorator(c) {}

    std::string getDescription() override {
        return coffee->getDescription() + " + Milk";
    }

    double cost() override {
        return coffee->cost() + 2.0;
    }
};

```
#### 🍬 加糖

```cpp
class SugarDecorator : public CoffeeDecorator {
public:
    SugarDecorator(Coffee* c) : CoffeeDecorator(c) {}

    std::string getDescription() override {
        return coffee->getDescription() + " + Sugar";
    }

    double cost() override {
        return coffee->cost() + 1.0;
    }
};
```
---

### 5️⃣ 使用方式（重点！）

```cpp
int main() {
    Coffee* coffee = new SimpleCoffee();
    coffee = new MilkDecorator(coffee);
    coffee = new SugarDecorator(coffee);

    std::cout << coffee->getDescription() << std::endl;
    std::cout << "Cost: " << coffee->cost() << std::endl;
}
```
**输出：**

```text
Simple Coffee + Milk + Sugar
Cost: 13
```
✅ 功能是**运行时动态叠加的**

---

## 五、C# 风格示例（更简洁）

```c#
interface Coffee {
    string GetDescription();
    double Cost();
}
```

```cpp
class SimpleCoffee : Coffee {
    public string GetDescription() => "Simple Coffee";
    public double Cost() => 10;
}
```

```c#
abstract class CoffeeDecorator : Coffee {
    protected Coffee coffee;
    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }

    public abstract string GetDescription();
    public abstract double Cost();
}
```

```cpp
class MilkDecorator : CoffeeDecorator {
    public MilkDecorator(Coffee coffee) : base(coffee) {}

    public override string GetDescription() =>
        coffee.GetDescription() + " + Milk";

    public override double Cost() =>
        coffee.Cost() + 2;
}
```
---

## 六、装饰模式的优点 ⭐

1. **避免类爆炸**
    
2. **符合开闭原则**
    
    - 对扩展开放，对修改关闭
        
3. **功能可以自由组合**
    
4. **比继承更灵活**
    

---

## 七、装饰模式 vs 继承（对比理解）

|方式|特点|
|---|---|
|继承|编译期固定，类数量爆炸|
|装饰|运行期组合，灵活扩展|

---

## 八、什么时候用装饰模式？

✅ 当你遇到：

- 功能需要**动态叠加**
    
- 组合方式很多
    
- 不想改原有类
    
- 想替代大量子类
    

📌 常见应用：

- Java IO 流（`BufferedInputStream`）
    
- UI 组件增强
    
- 权限、日志、缓存增强
    
- 游戏装备附魔系统 🎮