---
title:
  - 适配器模式
created: 2025-12-14
updated: 2025-12-14
type: 📘 知识节点
tags:
  - 面向对象
  - 设计模式
---
> 摘要：适配器模式用于将一个已有类的接口，转换成客户端期望的接口，使原本接口不兼容的类可以协同工作。

## 一、什么是适配器模式（通俗理解）

> **适配器模式 = 接口不兼容，但又必须一起工作时的“中间转换器”**

就像现实中的：

- **插头适配器**：
    
    - 插头是美标
        
    - 插座是国标
        
    - 本来插不上
        
    - 通过适配器 → 能用了
        

👉 **代码中的适配器**也是干这件事。

---

## 二、适配器模式的使用场景（小故事）

假设你遇到这样的需求：

- 你的系统**统一使用 USB 接口**
    
- 但现在有一个**老模块 / 第三方库**
    
- 它只支持 **Type-C 接口**
    
- 你 **不能改老代码**（可能是库、遗留系统）
    

💡 **怎么办？**

答案：  
👉 **写一个适配器，把 Type-C 转成 USB**

---

## 三、不使用适配器模式的情况（问题）

### ❌ 直接改原有类（不推荐）

```c#
class TypeCDevice
{
    public void UseTypeC()
    {
        Console.WriteLine("Using Type-C interface");
    }
}
```

你强行在业务中写：
```c#
class Computer
{
    public void Use(TypeCDevice device)
    {
        device.UseTypeC(); // 接口不统一
    }
}

```


❌ 问题：

- Computer 依赖具体实现
    
- 接口不统一
    
- 后期换设备要改大量代码
    
- 违反 **开闭原则**
    

---

## 四、使用适配器模式（推荐）

### 1️⃣ 目标接口（系统期望的接口）

#### C# 示例

```c#
// 系统期望的接口（USB）
interface IUsb
{
    void UseUsb();
}
```
---

### 2️⃣ 已存在的类（无法修改）

```c#
// 老接口（Type-C）
class TypeCDevice
{
    public void UseTypeC()
    {
        Console.WriteLine("Using Type-C interface");
    }
}

```
---

### 3️⃣ 适配器类（核心）

```c#
class TypeCToUsbAdapter : IUsb
{
    private TypeCDevice typeCDevice;

    public TypeCToUsbAdapter(TypeCDevice device)
    {
        typeCDevice = device;
    }

    public void UseUsb()
    {
        // 内部转换
        typeCDevice.UseTypeC();
    }
}

```
👉 **适配器 = 包一层 + 接口转换**

---

### 4️⃣ 客户端使用（完全不关心内部细节）

```c#
class Computer
{
    public void UseUsbDevice(IUsb usb)
    {
        usb.UseUsb();
    }
}

```

```c#
class Program
{
    static void Main()
    {
        Computer computer = new Computer();

        TypeCDevice typeCDevice = new TypeCDevice();
        IUsb adapter = new TypeCToUsbAdapter(typeCDevice);

        computer.UseUsbDevice(adapter);
    }
}

```
✅ 输出：
```c#
Using Type-C interface
```

---

## 五、C++ 风格示例（同一思想）
```cpp
#include <iostream>
using namespace std;

// 目标接口
class USB {
public:
    virtual void useUsb() = 0;
    virtual ~USB() {}
};

// 已存在类
class TypeCDevice {
public:
    void useTypeC() {
        cout << "Using Type-C interface" << endl;
    }
};

// 适配器
class Adapter : public USB {
private:
    TypeCDevice* device;
public:
    Adapter(TypeCDevice* d) : device(d) {}

    void useUsb() override {
        device->useTypeC();
    }
};

int main() {
    TypeCDevice device;
    USB* usb = new Adapter(&device);

    usb->useUsb();

    delete usb;
    return 0;
}

```

---

## 六、适配器模式的结构总结

|角色|作用|
|---|---|
|Target（目标接口）|客户端期望的接口|
|Adaptee（被适配者）|已存在但接口不兼容的类|
|Adapter（适配器）|做接口转换|
|Client（客户端）|只依赖目标接口|

---

## 七、适配器模式的优点

✅ **不修改原有代码**  
✅ **接口统一，解耦系统**  
✅ **符合开闭原则**  
✅ **方便接入第三方库**