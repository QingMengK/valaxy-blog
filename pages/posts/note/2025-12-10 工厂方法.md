---
title:
    - 工厂方法
created: 2025-12-10
updated: 2025-12-10
type: 📘 知识节点
tags:
  - 面向对象
  - 设计模式
---
> 工厂方法模式通过定义一个工厂接口，让每个产品都有自己的工厂，从而将对象创建延迟到子类，实现对扩展开放、对修改关闭，避免主程序依赖具体类。
# 📘 工厂方法模式（Factory Method）讲解

## 一、背景故事（为什么会出现工厂方法模式？）

你在开发一个“手机生产系统”，系统需要生产不同品牌的手机：

- iPhone
    
- 华为
    
- 小米
    
- 三星
    
- ……
    

一开始，你可能会采用简单工厂：

`if (type.equals("iphone")) return new IPhone(); else if (type.equals("huawei")) return new HuaweiPhone();`

但随着品牌增多，这段代码变成“超级大 if-else”，每增加一个品牌你就要修改一次。

这不仅：

- 违反开闭原则（对扩展开放，对修改关闭）
    
- 让工厂类越来越庞大
    
- 让系统依赖所有“具体产品类”
    

于是，“工厂方法模式”登场，它的主要目的就是 **消灭超大 if-else**、**消除对具体产品的依赖**、**让产品创建过程可扩展**。

---

## 二、工厂方法模式解决的核心问题

> **把“具体产品的创建”延迟到子类，让每个产品都有自己的工厂。**

也就是说：

- 工厂不再负责所有对象的创建
    
- 而是一个工厂创建一种产品
    
- 如果新增产品，只需要新增工厂
    
- 主程序不需要改动
    

它实现了最关键的一点：

### ✔ 主程序只依赖抽象，不依赖具体类

这让系统扩展性大大提高。

---

## 四、代码示例（最典型写法）

### 📌 1. 抽象产品

```java
interface Phone {     
void print(); }
```

### 📌 2. 具体产品

```java
class IPhone implements Phone {
    public void print() {
        System.out.println("IPhone");
    }
}

class HuaweiPhone implements Phone {
    public void print() {
        System.out.println("Huawei Phone");
    }
}

```

### 📌 3. 抽象工厂（核心）
```java
interface Factory {
    Phone createPhone();
}

```

### 📌 4. 具体工厂

```java
class IPhoneFactory implements Factory {
    public Phone createPhone() {
        return new IPhone();
    }
}

class HuaweiFactory implements Factory {
    public Phone createPhone() {
        return new HuaweiPhone();
    }
}

```
### 📌 5. 客户端（使用者）

```java
public class Main {
    public static void main(String[] args) {
        Factory factory = new HuaweiFactory();
        Phone phone = factory.createPhone();
        phone.print();
    }
}

```
---

## 五、工厂方法模式有什么优点？

### ✔ 1. **符合开闭原则（OCP）**

新增 XiaomiPhone？

你只需要：
```java
class XiaomiFactory implements Factory {
    public Phone createPhone() { return new XiaomiPhone(); }
}

```

主程序完全不用修改。

---

### ✔ 2. **消除 if-else + new 的强耦合**

主程序不再出现：

```java
new IPhone();
new HuaweiPhone();

```
只依赖工厂接口。

---

### ✔ 3. **产品创建过程可以被子类灵活扩展**

比如华为手机创建前可能需要做更多操作：

```java
class HuaweiFactory implements Factory {
    public Phone createPhone() {
        checkLicense();
        loadConfigs();
        return new HuaweiPhone();
    }
}

```
每种工厂可以定制自己的“生产流程”。

---

### ✔ 4. **每种产品对应一种工厂，结构更清晰**

扩展新产品时更加自然与规范。

---

## 六、工厂方法模式的缺点

工厂方法模式也有代价：

### ❌ 1. 类的数量会增加

每种产品都要有自己的工厂：

- IPhoneFactory
    
- HuaweiFactory
    
- XiaomiFactory
    
- ……
    

对于几百种产品的系统，工厂可能也会变多。

---

### ❌ 2. 简单需求下可能显得“过度设计”

如果系统只有两三个产品，并且创建过程很简单，用简单工厂更轻便。

---

## 七、和“简单工厂”的区别（高频面试题）

| 特性             | 简单工厂     | 工厂方法         |
| -------------- | -------- | ------------ |
| 产品数量           | 少        | 可以扩展到很多      |
| 扩展方式           | 修改一个大工厂  | 增加工厂类，不修改旧代码 |
| 是否违反开闭原则       | ❌ 是      | ✔ 否          |
| 是否消除大量 if-else | 部分       | 完全消除         |
| 创建逻辑           | 集中在一个工厂里 | 分散到多个子类工厂    |

一句话总结：

- **简单工厂：简单、集中，但不够灵活**
    
- **工厂方法：灵活、可扩展，但类更多**
    

---

## 八、一句话总结（适合放进笔记顶部）
