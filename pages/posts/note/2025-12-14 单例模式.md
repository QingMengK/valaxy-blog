---
title:
    - 单例模式
created: 2025-12-14
updated: 2025-12-14
type: 📘 知识节点
tags:
  - 面向对象
  - 设计模式
---
> 摘要：单例模式用于保证一个类在系统中只有一个实例，并提供统一的访问方式，常用于配置、日志、连接池等需要全局唯一对象的场景。

## 一、单例模式是什么？

**单例模式**的核心思想只有一句话：

> **一个类，在整个程序运行期间，只允许存在一个实例，并且对外提供一个全局访问点。**

也就是说：

- 不能随便 `new`
    
- 不管你在程序哪里用，拿到的**永远是同一个对象**
    

---

## 二、一个生活化的小背景 🌍

假设你在写一个系统，有一个 **系统配置类**：

- 里面存着数据库地址
    
- 服务器端口
    
- 是否开启日志等信息
    

💡 现实中：

- **系统配置只需要一份**
    
- 如果有多份配置对象，可能导致数据不一致、浪费资源、逻辑混乱
    

所以你希望：

- 配置类 **只能被创建一次**
    
- 所有人用的，都是这一份配置
    

👉 这正是 **单例模式** 要解决的问题。

---

## 三、不使用单例模式的情况 ❌

```java
class Config {
    public Config() {
        System.out.println("Config created");
    }
}
```
使用时：
```java
Config c1 = new Config();
Config c2 = new Config();
```
问题是：

- `c1` 和 `c2` 是 **两个不同对象**
    
- 每次 `new` 都会重新创建
    
- 完全无法控制实例数量
    
❗ 对于“只应该存在一个对象”的类来说，这是**不合理的**。

---

## 四、使用单例模式的情况 ✅（经典写法）

### 1️⃣ 最基础的单例实现（饿汉式）
```java
class Singleton {

    // 1. 私有静态唯一实例
    private static Singleton instance = new Singleton();

    // 2. 私有构造方法，防止外部 new
    private Singleton() {}

    // 3. 公共访问方法
    public static Singleton getInstance() {
        return instance;
    }
}

```

使用：
```java
Singleton s1 = Singleton.getInstance();
Singleton s2 = Singleton.getInstance();

System.out.println(s1 == s2); // true

```

✔ 不管调用多少次 `getInstance()`  
✔ 永远是同一个对象

---

## 五、单例模式的关键点（一定要记住）

### ✅ 1. 构造方法必须是 `private`

防止外部通过 `new` 创建对象

### ✅ 2. 类内部保存唯一实例

通常是 `static` 成员变量

### ✅ 3. 提供统一访问入口

通常是 `getInstance()`

---

## 六、常见的单例实现方式（了解即可）

### ① 饿汉式（上面那种）

- 类加载时就创建实例
    
- **线程安全**
    
- 可能浪费内存（用不到也创建）
    

### ② 懒汉式（用的时候再创建）

```java
class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

⚠ 在多线程环境下 **不安全**

---

### ③ 双重检查锁（常用，面试常考）

```java
class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

✔ 线程安全  
✔ 性能好  
✔ 工程中常用

---

## 七、单例模式的优点与缺点

### 👍 优点

- 保证全局唯一实例
    
- 节省资源（如数据库连接、配置对象）
    
- 统一管理共享状态
    

### 👎 缺点

- 依赖全局状态，测试不方便
    
- 过度使用会导致代码耦合度高
    

---

## 八、典型使用场景

✔ 日志系统（Logger）  
✔ 配置管理类  
✔ 线程池  
✔ 缓存管理  
✔ 数据库连接池（核心控制对象）