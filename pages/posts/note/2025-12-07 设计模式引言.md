---
title:
  - 设计模式
created: 2025-12-06
updated: 2025-12-06
type: 📘 知识节点
tags:
  - 面向对象
  - 设计模式
  - 读书笔记
---
> 摘要：

### 设计模式怎样解决设计问题
#### 1、寻找合适的对象
#### 2、决定对象的粒度
#### 3、指定对象窗口
  对象声明的每一个操作指定操作名、作为参数的对象和返回值，这就是所谓的操作的**型构 (signature)** 。对象操作所定义的所有操作型构的集合被称为该对象的**接口 (interface)**。
  **类型(type)** 是用来标识特定接口的一个名字。如果一个对象接受 "Window" 接口所定义的所有操作请求，那么我们就说该对象具有 "Window" 类型。
#### 4、描述对象的实现
  对象通过**实例化**类来创建，此对象被称为该类的**实例**。当实例化类时，要给对象的内部数据(由**实例变量**组成)分配空间，并将操作与这些数据联系起来。对象的许多类似实例是有实例化同一个类来创建的。
  新的类可以由已存在的类通过**类继承(class inheritance)** 来定义。当子类继承父类时，子类包含了父类的所有数据和操作。子类的实例对象包含所有的子类和父类定义的数据，且它们能完成子类和父类定义的所有操作。

  **抽象类**（abstract class）的主要目的是它的子类定义公共接口。一个抽象类将把它的部分或全部操作的实现延时到子类中，因此，一个抽象类不能被实例化。在抽象类中定义却没有实现的操作被称为**抽象操作**。飞抽象类被称为具体类。

  **混入类**(mixin class)是给其他类提供可选择的接口或功能的类。它与抽象类一样不能实例化。混入类要求多继承。

##### 1.类继承与接口继承的比较
  类继承根据一个对象的实现定义了另一个对象的实现。它是代码和表示的共享机制。然而，接口继承(或子类型化)描述了一个对象什么时候能被用来替代另一个对象。
  很多语言并不显式的区分这两个概念，所以容易被混淆。

##### 2.对接口编程，而不是对实现编程
  当继承被恰当使用时，所有从抽象类导出的类将共享该抽象类的接口。这意味着子类仅仅添加或重定义操作，而没有隐藏父类的操作。
  这时，所有的子类都能响应抽象类接口中的请求，从而子类的类型都是抽象类的子类型。

  只根据抽象类中定义的接口来操纵对象有以下两个好处：
  1）客户无须知道他们使用对象的特定类型，只须对象有客户所期望的接口。
  2）客户无须知道他们使用的对象使用什么类来实现的，他们只须知道定义接口的抽象类。
  这将极大的减少子系统之间的相互依赖关系，也产生了可复用的面下对象设计的如下原则：
  ***针对接口编程，而不是针对实现编程。***
  不将变量声明为某个特定的具体类的实例对象，而是让它遵从抽象类所定义的接口。
#### 运用复用机制
##### 1.继承和组合的比较(组合优于继承)
 类继承允许你根据其他类的实现定义一个累的实现。这种通过生成子类的复用通常被称为**白箱复用**。
 对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过主创或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为**黑箱复用**
 类继承的不足之处：因为继承对子类揭示了其父类的实现细节，所以继承常被认为“破坏了封装性”。子类中的实现与它的父类有如此紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。
 当你需要复用子类时，实现上的依赖性就会产生一些问题。如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。一个可用的解决方法就是只继承抽象类，因为抽象类通常提供较少的实现。

  组合要求对象遵守彼此的接口约定，进而要求更仔细地定义接口，而这些接口并不妨碍你将一个对象和其他对象一起使用。因为对象只能通过接口访问，所以我们并不破坏封装性；只要类型一致，运行时刻还可以用一个对象来替代另一个对象；更进一步，因为对象的实现是基于接口写的，所以实现上存在较少的依赖关系。

  对象组合对系统设计还有另一个作用，即优先使用对象组合有助于你保持每个类被封装，并被集中在单个任务上。另一方面，基于对象的组合的设计会有更多的对象(而有较少的类)，且系统的行为将依赖于对象间的关系而不是被定义在某个类中。
  面向对象设计的第二个原则：
  ***优先使用对象组合，而不是类继承***
  设计者往往过度使用了继承这种复用技术。但依赖于对象组合技术的设计却有更好的复用性(或更简单)。
##### 2.委托
  委托是一种组合方法，它使组合具有与继承相同的复用能力。在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给它的**代理者**。使用继承时，被继承的操作总能引用接受的对象，C++中通过this成员变量，Smalltalk中则通过self。委托方式为了得到同样的效果，接受请求的对象将自己传给被委托者，使被委托的操作可以引用接受请求的对象。
  委托的主要优点在于它便于运行时刻组合对象操作以及改变这些操作的组合方式。假定矩形对象和圆对象有相同的类型，我们只需简单的用圆对象替换矩形对象，则得到的窗口就是圆形的。

#### 关联运行时刻和编译时刻的结构
  **聚合**和**相识**
  **聚合**意味着一个对象拥有另一个对象或对另一个对象负责。一般我们称一个对象包含另一个对象或者是另一个对象的一部分。聚合意味着聚合对象和其所有者具有相同的生命周期。
  **相识**意味着一个对象仅仅知道另一个对象。有时相识也被称为"关联"或"引用"关系。相识的对象可能请求彼此的操作，但它们不为对方负责。相识是一种比聚合要弱的关系，它只标识了对象间较松散的耦合关系。
  聚合和相识容易混淆，因为它们通常以相同的方法实现。
  从根本上讲，是聚合还是相识是由你的意图而不是显式的语言机制决定的。
#### 设计应支持变化

### 怎样选择设计模式
考虑设计模式是怎样解决设计问题的
浏览模式的意图部分
研究模式怎样互相关联
研究目的相的模式
检查重新设计的原因
考虑你的设计中哪些是可变的